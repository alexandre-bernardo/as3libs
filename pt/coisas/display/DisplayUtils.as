///////////////////////////////////////////////////////////
//  DisplayUtils.as
//  Macromedia ActionScript Implementation of the Class DisplayUtils
//  Generated by Enterprise Architect
//  Created on:      12-Ago-2009 18:40:50
//  Original author: Alexandre
///////////////////////////////////////////////////////////

package pt.coisas.display
{
	import flash.display.Bitmap;
	import flash.display.BitmapData;
	import flash.display.DisplayObject;
	import flash.display.MovieClip;
	import flash.display.PixelSnapping;
	import flash.display.Shape;
	import flash.display.Sprite;
	import flash.geom.Matrix;
	import flash.geom.Point;
	import flash.geom.Rectangle;
	/**
	 * @author Alexandre
	 * @version 1.0
	 * @created 12-Ago-2009 18:40:50
	 */
	public class DisplayUtils {
		static public const TILE:String = "tile";
		static public const HORIZONTAL:String = "horizontal";
		static public const VERTICAL:String = "vertical";
		static public const DIAGONAL:String = "diagonal";
	    static private var allowInstantiation:Boolean;
	    static private var instance:DisplayUtils;
		
		public function DisplayUtils() {
			if (!allowInstantiation) {
				throw new Error("Error: Instantiation failed: Use DisplayUtils.someMethod() instead of new.");
			}
		}
	    static private function getInstance():DisplayUtils {
			if (instance == null) {
				allowInstantiation = true;
				instance = new DisplayUtils();
				allowInstantiation = false;
			}
			return instance;
	    }
		static public function breakImageApart(image:Object, type:String, options:Object):Object {
			//TODO check if image is bitmapData
			if(!(image is BitmapData)){
				var tempBitmap:BitmapData = new BitmapData(image.width, image.height, true, 0x00000000);
				tempBitmap.draw(image as Sprite);
				image = tempBitmap;
			}
			switch (type) {
				case DisplayUtils.TILE:
					if(!options.center) options.center = true;
					if(!options.smoothing) options.smoothing = false;
					return tileImage(image as BitmapData, options.width, options.height, options.center, options.smoothing);
					break;
				case DisplayUtils.HORIZONTAL:
					return tileImage(image as BitmapData, image.width, Math.ceil(image.height / options.stripeNumber));
					break;
				case DisplayUtils.VERTICAL:
					return tileImage(image as BitmapData, Math.ceil(image.width / options.stripeNumber), image.height);
					break;
				case DisplayUtils.DIAGONAL:
					return tileImageDiagonal(image as BitmapData, options.stripeNumber, options.angle);
					break;
			}
			return null;
		}
		static private function tileImageDiagonal(image:BitmapData, stripeNumber:int, angle:Number):Object {
			var angle_in_radians:Number = Math.PI * 2 * (angle / 360);
			var transXX:Number = angle > 0 ? Math.cos(Math.PI / 2 - angle_in_radians) * image.height : 0;
			var transYY:Number = angle > 0 ? 0 : Math.cos(Math.PI / 2 + angle_in_radians) * image.width;
			var rotatedWidth:Number = angle > 0 ? transXX + Math.cos(angle_in_radians) * image.width
												: Math.sin(Math.PI / 2 - angle_in_radians) * image.width - Math.sin(angle_in_radians) * image.height;
			var rotatedHeight:Number = angle > 0 ? Math.sin(Math.PI / 2 - angle_in_radians) * image.height + Math.sin(angle_in_radians) * image.width
												 : transYY + Math.cos(angle_in_radians) * image.height;
			
			var rotationMatrix:Matrix = new Matrix();
			rotationMatrix.rotate(angle_in_radians);
			rotationMatrix.translate(transXX, transYY);
			var matrixImage:BitmapData = new BitmapData(rotatedWidth, rotatedHeight, true, 0x00000000);
			matrixImage.draw(image, rotationMatrix,null,null,null,true);
			var rotatedImage:BitmapData = matrixImage;
			
			var tiledImage:Object = tileImage(rotatedImage, Math.ceil(rotatedImage.height / stripeNumber), Math.ceil(rotatedImage.height), true, false);
			
			rotationMatrix.invert();
			tiledImage.sprite.transform.matrix = rotationMatrix;
			//tiledImage.sprite.rotation = -angle;
			
			var newSp:Sprite = new Sprite();
			newSp.addChild(tiledImage.sprite);
			newSp.scrollRect = new Rectangle(0,0,image.width, image.height); //FIXME!
			tiledImage.sprite = newSp;
			
			
			//trace(transXX +"|" + transYY);
			//trace(tiledImage.sprite.x +"|" + tiledImage.sprite.y);
			
			
			
			//tiledImage.sprite.x = 0;
			//tiledImage.sprite.y = 0;
			//tiledImage.sprite.scrollRect = new Rectangle(0, 0, image.width, image.height);
			
			//var tiledImage:Object = tileImage(image, Math.ceil(image.height / stripeNumber), image.height, false, angle);
			
			
			return tiledImage;
		}
		static private function tileImage(image:BitmapData, tileWidth:int, tileHeight:int, center:Boolean = true, smoothing:Boolean = false, xPadding:Number = 0, yPadding:Number = 0):Object{
			var imageArray:Array = [];
			var tempTile:BitmapData;
			var newTileBmp:Bitmap;
			var newTile:Sprite;
			var fullImage:Sprite = new Sprite();
			
			if(center){
				for (var i:int = 0; i < image.height / tileHeight; i++) {
					for (var j:int = 0; j < image.width / tileWidth; j++) {
						//tempTile = copyRectangle(image, j * tileWidth, i * tileHeight, tileWidth, tileHeight, angle);
						tempTile = new BitmapData(tileWidth, tileHeight, true, 0x00000000);
						tempTile.copyPixels(image, new Rectangle(j * tileWidth, i * tileHeight, tileWidth, tileHeight), new Point(0,0));
						newTileBmp = new Bitmap(tempTile, PixelSnapping.NEVER, smoothing);
						
						newTile = new Sprite();
						newTile.mouseEnabled = false; //Optimization
						
						newTileBmp.x = -tileWidth / 2;
						newTileBmp.y = -tileHeight / 2;
						
						newTile.addChild(newTileBmp);
						newTile.x = j * tileWidth + tileWidth / 2 + xPadding;
						newTile.y = i * tileHeight + tileHeight / 2 + yPadding;
						
						imageArray.push(newTile);
						fullImage.addChild(newTile);
					}
				}
			} else {
				for (var k:int = 0; k < image.height / tileHeight; k++) {
					for (var p:int = 0; p < image.width / tileWidth; p++) {
						//tempTile = copyRectangle(image, j * tileWidth, i * tileHeight, tileWidth, tileHeight, angle);
						tempTile = new BitmapData(tileWidth, tileHeight, true, 0x00000000);
						tempTile.copyPixels(image, new Rectangle(p * tileWidth, k * tileHeight, tileWidth, tileHeight), new Point(0,0));
						newTileBmp = new Bitmap(tempTile, PixelSnapping.NEVER, smoothing);
						
						//newTile = new Sprite();
						//newTile.mouseEnabled = false; //Optimization
						
						//newTileBmp.x = -tileWidth / 2;
						//newTileBmp.y = -tileHeight / 2;
						
						//newTile.addChild(newTileBmp);
						newTileBmp.x = p * tileWidth + xPadding;
						newTileBmp.y = k * tileHeight + yPadding;
						
						imageArray.push(newTileBmp);
						fullImage.addChild(newTileBmp);
					}
				}
			}
			return {array:imageArray, sprite:fullImage, width:tileWidth, height:tileHeight};
		}
		static private function copyRectangle(origBitmap:BitmapData, recX:Number, recY:Number, recW:Number, recH:Number, angle_deg:Number):BitmapData {
			var destBitmap:BitmapData = new BitmapData(recW, recH);

			// degrees > radians
			var angle:Number = Math.PI * 2 * (angle_deg / 360);
			// sin and cos for angle
			var sinVal:Number = Math.sin(angle);
			var cosVal:Number = Math.cos(angle);
			
			var nx:Number = 0;
			var ny:Number = 0;
			var colVal:Number;
			
			destBitmap.lock();
			
			// going through rectangle pixels
			for (var i:int = recX; i < (recX+recW); i++) {
				for (var j:int = recY; j < (recY+recH); j++) {
					// getting position of original pixel / calculating rotation
					nx = (i-recX)*cosVal-(j-recY)*sinVal;
					ny = (j-recY)*cosVal+(i-recX)*sinVal;
					nx = Math.round(recX+nx);
					ny = Math.round(recY+ny);
					// getting pixel value with alpha
					colVal = origBitmap.getPixel32(nx, ny);
					// setting pixel value with alpha
					destBitmap.setPixel32(i - recX, j - recY, colVal);
				}
			}
			
			destBitmap.unlock();
			
			return destBitmap;
		}
		
		static public function flatten(mc:*, type:Class = null):* {
			type = type || Sprite; //default type
			var bmData:BitmapData;
			if(mc is BitmapData){
				bmData = mc;
			} else if(mc){
				bmData = new BitmapData(mc.width, mc.height, true, 0x00000000);
				bmData.draw(mc);
			} else {
				return null;
			}
			
			if(type === BitmapData) return bmData;
			else if(type === Bitmap) return new Bitmap(bmData);
			else if(type === Sprite){
				var sp:Sprite = new Sprite();
				sp.addChild(new Bitmap(bmData));
				return sp;
			}
			else throw new Error("No type defined or unknown type!");
		}
		
		static public function flattenMovieclips(mcs:Array, type:Class = null):* {
			type = type || Sprite; //default type
			
			//mcs must have the same parent!
			var flattenedSprite:Sprite = new Sprite();
			for (var i:int = 0; i < mcs.length; i++) {
				flattenedSprite.addChild(mcs[i]);
			}
			
			return flatten(flattenedSprite, type);
		}
		
		public static function createInnerMask(obj:DisplayObject, add:Boolean = true):void{
			var maskMC:Shape = new Shape();
			if(add) obj.parent.addChild(maskMC);
			
			var objRect:Rectangle = obj.getRect(obj.parent);
			maskMC.graphics.beginFill(0xFFFFFF);
			maskMC.graphics.drawRect(objRect.x, objRect.y, objRect.width, objRect.height);
			maskMC.graphics.endFill();
			obj.mask = maskMC;
		}
		public static function destroyMask(obj):void{
			obj.parent.removeChild(obj.mask);
			obj.mask = null;
		}
	}//end DisplayUtils
}