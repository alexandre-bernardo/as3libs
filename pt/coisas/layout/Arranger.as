///////////////////////////////////////////////////////////
//  Arranger.as
//  Macromedia ActionScript Implementation of the Class Arranger
//  Generated by Enterprise Architect
//  Created on:      08-Jul-2009 17:34:14
//  Original author: Alexandre Bernardo
///////////////////////////////////////////////////////////

package pt.coisas.layout
{
	import flash.display.DisplayObject;
	import flash.display.Sprite;
	import flash.geom.Point;
	import flash.geom.Rectangle;
	import pt.coisas.math.PM_PRNG;
	
	/**
	 * @author Alexandre Bernardo
	 * @version 0.1
	 * @created 08-Jul-2009 17:34:14
	 */
	public class Arranger {
	    static public const HORIZONTAL:String = "horizontal";
	    static public const VERTICAL:String = "vertical";
	    static public const TILED_HORIZONTAL:String = "tiled_horizontal";
	    static public const TILED_VERTICAL:String = "tiled_vertical";
		static public const SCATTER_RANDOM_OVERLAP:String = "scatter_random_overlap";
		static public const SCATTER_RANDOM:String = "scatter_random";
		static public const SCATTER_DISTRIBUTED:String = "scatter_distributed";
		public static const ALIGN_TOP:String = "TOP";
		public static const ALIGN_BOTTOM:String = "BOTTOM";
		public static const ALIGN_LEFT:String = "LEFT";
		public static const ALIGN_RIGHT:String = "RIGHT";
		public static const ALIGN_CENTER:String = "CENTER";
	    static private var allowInstantiation:Boolean;
	    static private var instance:Arranger;
		
	    public function Arranger() {
			if (!allowInstantiation) {
				throw new Error("Error: Instantiation failed: Use Arranger.list() instead of new.");
			}
	    }
	    static private function getInstance():Arranger {
			if (instance == null) {
				allowInstantiation = true;
				instance = new Arranger();
				allowInstantiation = false;
			}
			return instance;
	    }
	    /**
	     * 
	     * @param items
	     * @param padding
	     * @param xPos
	     * @param yPos
	     * @param direction
	     * @param nTiles
	     */
	    static public function list(items:*, direction:String = VERTICAL, options:Object = null):void {
			//padding:Number = 2, xPos:Number = 0, yPos:Number = 0, direction:String = VERTICAL, nTiles:int = 1, align:String = ALIGN_LEFT + ALIGN_TOP
			//direction = direction || VERTICAL;
			options = options || {};
			
			if(items is DisplayObject){
				var itemsCopy:Array = [];
				for (var i:int = 0; i < items.numChildren; i++) {
					itemsCopy.push(items.getChildAt(i));
				}
				items = itemsCopy;
			}
			
			switch (direction) {
				case HORIZONTAL:
					options.nTiles = 1;
				case TILED_VERTICAL:
					listHorizontal(items, options);
					break;
				case VERTICAL:
					options.nTiles = 1;
				case TILED_HORIZONTAL:
					listVertical(items, options);
					break;
			}
	    }
	    /**
	     * 
	     * @param items
	     * @param padding
	     * @param xPos
	     * @param yPos
		 * @param nTiles
	     */
	    static private function listHorizontal(items:Array, options:Object):void {
			//padding:Number, xPos:Number, yPos:Number, nTiles:int, rect:Rectangle, align:String
			var padding:Number = options['padding'] || 0;
			var padding_x:Number = options['padding_x'] || 0;
			var padding_y:Number = options['padding_y'] || 0;
			var xPos:Number = options['xPos'] || (options['rect'] ? options.rect.x : 0);
			var yPos:Number = options['yPos'] || (options['rect'] ? options.rect.y : 0);
			var nTiles:int = options['nTiles'] || 1;
			var rect:Rectangle = options['rect'] || null;
			var align:String = options["align"] || ALIGN_LEFT + ALIGN_TOP;
			var round:Boolean = options['round'] || false;
			var ladder_y:Number = options['ladder_y'] || 0;
			var nItems:int = items.length;
			var newX:Number = xPos;
			var newY:Number = yPos;
			
			/*
			for (var i:int = 0; i < items.length; i++) {
				items[i].x = round ? Math.floor(newX) : newX;
				items[i].y = round ? Math.floor(newY) : newY;
				newX = (i+1) % nTiles == 0 ? items[i].x + items[i].width + padding : newX;
				newY = (i+1) % nTiles == 0 ? yPos : items[i].y + items[i].height + padding;
			}
			*/
			if(align.match(ALIGN_LEFT)){
				for (var i:int = 0; i < nItems; i++) {
					items[i].x = (round ? Math.floor(newX) : newX);
					items[i].y = (round ? Math.floor(newY) : newY) + ladder_y * i;
					newX = (i+1) % nTiles == 0 ? items[i].x + items[i].width + padding_x : newX;
					newY = (i+1) % nTiles == 0 ? yPos : items[i].y + items[i].height + padding_y;
				}
			}
			if(align.match(ALIGN_CENTER)){
				for (var j:int = 0; j < nItems; j++) {
					setPosition(items[j], newX, rect.y + rect.height/ 2 - items[j].height / 2, round);
					newX = (j+1) % nTiles == 0 ? items[j].x + items[j].width + padding : newX;
				}
			}
	    }
	    /**
	     * 
	     * @param items
	     * @param padding
	     * @param xPos
	     * @param yPos
		 * @param nTiles
	     */
	    static private function listVertical(items:Array, options:Object):void {
			//padding:Number, xPos:Number, yPos:Number, nTiles:int, rect:Rectangle, align:String
			var padding:Number = options['padding'] || 0;
			var padding_x:Number = options['padding_x'] || 0;
			var padding_y:Number = options['padding_y'] || 0;
			var xPos:Number = options["xPos"] || (options["rect"] ? options.rect.x : 0);
			var yPos:Number = options["yPos"] || (options["rect"] ? options.rect.y : 0);
			var nTiles:int = options["nTiles"] || 1;
			var rect:Rectangle = options["rect"] || null;
			var align:String = options["align"] || ALIGN_LEFT + ALIGN_TOP;
			var round:Boolean = options['round'] || false;
			var ladder_x:Number = options['ladder_x'] || 0;
			var nItems:int = items.length;
			var newX:Number = xPos;
			var newY:Number = yPos;
			
			if(align.match(ALIGN_LEFT)){
				for (var i:int = 0; i < nItems; i++) {
					items[i].x = (round ? Math.floor(newX) : newX) + ladder_x * i;
					items[i].y = (round ? Math.floor(newY) : newY);
					newX = (i+1) % nTiles == 0 ? xPos : items[i].x + items[i].width + padding_x;
					newY = (i+1) % nTiles == 0 ? items[i].y + items[i].height + padding_y : newY;
				}
			}
			if(align.match(ALIGN_CENTER)){
				for (var j:int = 0; j < nItems; j++) {
					setPosition(items[j], rect.x + rect.width / 2 - items[j].width / 2, newY, round);
					newY = (j+1) % nTiles == 0 ? items[j].y + items[j].height + padding : newY;
				}/*
				for (var i:int = 0; i < items.length; i++) {
					items[i].x = newX;
					items[i].y = newY;
					newX = (i+1) % nTiles == 0 ? xPos : items[i].x + items[i].width + padding;
					newY = (i+1) % nTiles == 0 ? items[i].y + items[i].height + padding : newY;
				}*/
			}
	    }
		
		static public function distribute(items:Array, rect:Rectangle = null):void {
			//items must have same parent!!
			if (!rect) rect = items[0].parent.getBounds(items[0].parent);
			/*
			if(items.length == 1) setPosition(items[0], rect.x + rect.width / 2 - items[0].width / 2, 
														rect.y + rect.height / 2 - items[0].height / 2);
			*/
			var nItems:int = items.length;
			var maxWidth:Number = 0;
			var maxHeight:Number = 0;
			
			for (var j:int = 0; j < nItems; j++) {
				maxWidth += items[j].width;
				maxHeight += items[j].height;
			}
			
			var xPadding:int = Math.ceil((rect.width - maxWidth) / (nItems + 1));
			var yPadding:int = Math.ceil((rect.height - maxHeight) / (nItems + 1));
			
			
			
			/*
			if(maxWidth > rect.width){
				if(maxHeight > rect.height){
					if(maxWidth > maxHeight){
						listVertical(items, {padding:yPadding, rect:rect, align:ALIGN_CENTER, yPos:yPadding});
					} else {
						trace("1");
						
					}
				} else {
					if (maxWidth > maxHeight){
						listVertical(items, {padding:yPadding, rect:rect, align:ALIGN_CENTER, yPos:yPadding});
					} else {
						trace("2");
					}
				}
			} else {
				if(maxHeight > rect.height){
					if(maxWidth > maxHeight){
						trace("3");
					} else {
						listHorizontal(items, {padding:xPadding, rect:rect, align:ALIGN_CENTER, xPos:xPadding});
					}
				} else {
					if (maxWidth > maxHeight){
						trace("4");
					} else {
						listHorizontal(items, {padding:xPadding, rect:rect, align:ALIGN_CENTER, xPos:xPadding});
					}
				}
			}*/
		}
		
		static private function setPosition(item:DisplayObject, xx:Number, yy:Number, round:Boolean):void{
			//align item top left
			var rect:Rectangle = item.getBounds(item);
			item.x = xx - rect.x * item.scaleX;
			item.y = yy - rect.y * item.scaleY;
			if (round){
				item.x = Math.floor(item.x);
				item.y = Math.floor(item.y);
			}
		}
		
		static public function scatter(items:Array, type:String = SCATTER_RANDOM, padding:int = 0, rect:Rectangle = null):void {
			//items must have same parent!!
			if(!rect) rect = items[0].parent.getBounds(items[0].parent);
			var parent:DisplayObject = items[0].parent;
			var prng:PM_PRNG = new PM_PRNG(Math.random()*123456789);
			//trace(parent);
			switch (type) {
				case SCATTER_RANDOM_OVERLAP:
					for (var i:int = 0; i < items.length; i++) {
						items[i].x = prng.nextIntRange(rect.left, rect.right - items[i].width);
						items[i].y = prng.nextIntRange(rect.top, rect.bottom - items[i].height);
					}
					break;
				case SCATTER_RANDOM:
					for (var j:int = 0; j < items.length; j++) {
						items[j].x = prng.nextIntRange(rect.left, rect.right - items[j].width);
						items[j].y = prng.nextIntRange(rect.top, rect.bottom - items[j].height);
					}
					/*
					var newPoint:Point;
					for (var i:int = 0; i < items.length; i++) {
						newPoint = getNextPoint(items, i, parent, rect);
						items[i].x = newPoint.x;
						items[i].y = newPoint.y;
						//trace(items[i].x +"|"+ items[i].y);
					}*/
					break;
				case SCATTER_DISTRIBUTED:
					//list(items, padding, rect.x, rect.y, TILED_HORIZONTAL);
					
					break;
			}
		}
		
		static private function checkOverlap():Boolean {
			return true;
		}
		
		static private function getNextPoint(items:Array, itemIndex:int, parent:DisplayObject, parentRect:Rectangle):Point{
			var rect:Rectangle;
			if(itemIndex == 0){
				items[itemIndex].x = Math.floor(parentRect.left + Math.random() * (parentRect.right - items[itemIndex].width));
				items[itemIndex].y = Math.floor(parentRect.top + Math.random() * (parentRect.bottom - items[itemIndex].height));
			}
			for (var i:int = 0; i < itemIndex; i++) {
				rect = items[itemIndex].getBounds(parent);
				if(i != itemIndex && rect.intersects(items[i].getBounds(parent))){
					trace(rect + "|" + items[i].getBounds(parent));
					items[itemIndex].x = Math.floor(parentRect.left + Math.random() * (parentRect.right - items[itemIndex].width));
					items[itemIndex].y = Math.floor(parentRect.top + Math.random() * (parentRect.bottom - items[itemIndex].height));
				}
			}
			return new Point(items[itemIndex].x, items[itemIndex].y);
		}
	}//end Arranger
}